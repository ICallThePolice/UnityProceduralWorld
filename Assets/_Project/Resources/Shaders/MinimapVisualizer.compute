#pragma kernel VisualizeGrid

struct SiteInfo {
    float posX;
    float posZ;
    uint biomeID;
    uint isPaired; // Используем uint вместо bool для совместимости
};

StructuredBuffer<SiteInfo> _SiteData;
int _SiteCount;
RWTexture2D<float4> _Result;
float4 _PlayerPos;
// Добавим масштаб, чтобы его можно было настраивать
float _MinimapScale; 

// ... (функция GetColorForBiome остается без изменений) ...
float4 GetColorForBiome(uint biomeId, uint isPaired)
{
    // Используем isPaired == 1 для проверки
    if (isPaired == 1) {
        return float4(1, 1, 1, 1); 
    }
    switch (biomeId)
    {
        case 1: return float4(0.2, 0.8, 0.2, 1); // Зеленый
        case 2: return float4(0.8, 0.2, 0.2, 1); // Красный
        case 3: return float4(0.2, 0.2, 0.8, 1); // Синий
        case 4: return float4(0.8, 0.8, 0.2, 1); // Желтый
        default: return float4(0.3, 0.3, 0.3, 1); // Серый
    }
}


[numthreads(8,8,1)]
void VisualizeGrid (uint3 id : SV_DispatchThreadID)
{
    // Рассчитываем, какую координату мира представляет этот пиксель
    float worldPosX = _PlayerPos.x + (id.x - 256) * _MinimapScale;
    float worldPosZ = _PlayerPos.y + (id.y - 256) * _MinimapScale;

    // Находим "координату сайта" для этого пикселя
    int siteX = floor(worldPosX);
    int siteZ = floor(worldPosZ);

    // Изначально пиксель черный (нейтральный)
    _Result[id.xy] = float4(0, 0, 0, 1);

    // Пробегаем по всем сайтам, чтобы найти тот, который соответствует координате нашего пикселя
    for (int i = 0; i < _SiteCount; i++)
    {
        // Сравниваем целочисленные координаты
        if (floor(_SiteData[i].posX) == siteX && floor(_SiteData[i].posZ) == siteZ)
        {
            _Result[id.xy] = GetColorForBiome(_SiteData[i].biomeID, _SiteData[i].isPaired);
            return; // Нашли, закрасили, выходим
        }
    }
}