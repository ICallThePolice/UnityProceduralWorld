// ФАЙЛ: BiomeMapGenerator.compute (ИСПРАВЛЕННАЯ ВЕРСИЯ)
#pragma kernel GenerateBiomeMap

// Входные данные от CPU
RWTexture2D<float4> Result;
float2 WorldOffset;
float AtlasSize;
StructuredBuffer<float3> BiomeData;

// --- Упрощенная и рабочая версия шума ---
float2 hash(float2 p)
{
    p = float2(dot(p, float2(127.1, 311.7)),
               dot(p, float2(269.5, 183.3)));
    return -1.0 + 2.0 * frac(sin(p) * 43758.5453123);
}

float simplex_noise(float2 p) {
    const float K1 = 0.366025404; // (sqrt(3)-1)/2
    const float K2 = 0.211324865; // (3-sqrt(3))/6

    float2 i = floor(p + (p.x + p.y) * K1);
    float2 a = p - i + (i.x + i.y) * K2;
    float2 o = (a.x > a.y) ? float2(1.0, 0.0) : float2(0.0, 1.0);
    float2 b = a - o + K2;
    float2 c = a - 1.0 + 2.0 * K2;

    float3 h = max(0.5 - float3(dot(a, a), dot(b, b), dot(c, c)), 0.0);
    // Исправлена ошибка в вызове hash()
    float3 n = h * h * h * h * float3(dot(a, hash(i)), dot(b, hash(i + o)), dot(c, hash(i + 1.0)));

    return dot(n, float3(70.0, 70.0, 70.0));
}

float GetNoise(float2 pos, float frequency)
{
    return simplex_noise(pos * frequency);
}
// --- КОНЕЦ БЛОКА ШУМА ---

[numthreads(8,8,1)]
void GenerateBiomeMap (uint3 id : SV_DispatchThreadID)
{
    float2 globalPos = WorldOffset + id.xy;

    // Параметры шума (можно будет вынести в настройки)
    float chaosFreq = 0.002;
    float saturationFreq = 0.002;

    float chaos = GetNoise(globalPos, chaosFreq);
    float saturation = GetNoise(globalPos + float2(123.4, -543.2), saturationFreq);
    float2 targetPos = float2(chaos, saturation);

    float closestDistSq = 1000000.0;
    float secondClosestDistSq = 1000000.0;
    uint closestIdx = 0;
    uint secondClosestIdx = 0;

    for (uint i = 0; i < (uint)AtlasSize; i++)
    {
        float2 biomePos = BiomeData[i].yz;
        float distSq = dot(targetPos - biomePos, targetPos - biomePos);
        if (distSq < closestDistSq)
        {
            secondClosestDistSq = closestDistSq;
            secondClosestIdx = closestIdx;
            closestDistSq = distSq;
            closestIdx = i;
        }
        else if (distSq < secondClosestDistSq)
        {
            secondClosestDistSq = distSq;
            secondClosestIdx = i;
        }
    }
    
    float blendFactor = 0.0;
    if (AtlasSize > 1 && secondClosestDistSq < 999999.0)
    {
        float dist1 = sqrt(closestDistSq);
        float dist2 = sqrt(secondClosestDistSq);
        blendFactor = saturate(dist1 / (dist1 + dist2 + 0.0001));
    }
    
    float primaryID = BiomeData[closestIdx].x;
    float secondaryID = (AtlasSize > 1) ? BiomeData[secondClosestIdx].x : primaryID;
    
    Result[id.xy] = float4(primaryID, secondaryID, blendFactor, 0);
}